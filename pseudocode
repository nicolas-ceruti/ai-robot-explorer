Documento de Pseudocódigos: Robô Explorador Inteligente

Alunos:  Nicolas Ceruti, Felipe Giovanella, Gustavo Campestrini, Julia Welter

================================================================
Etapa 1: Agente Reativo Simples
================================================================
Objetivo: Encontrar as quatro paredes do grid.
Lógica: O agente se move em linha reta até colidir com um limite e então escolhe uma nova direção.

INÍCIO
    // Estado interno do agente
    DEFINIR paredes_encontradas COMO um conjunto vazio
    DEFINIR direcao_atual COMO uma direção aleatória inicial (ex: Norte)

    // Loop principal de exploração
    ENQUANTO o tamanho de paredes_encontradas < 4 FAÇA

        // Ação: Tenta mover na direção que está "lembrando"
        TENTAR mover o robô na direcao_atual

        // Percepção e Regra: Se o movimento falhou, mude de direção
        SE o movimento falhou (colisão com limite) ENTÃO
            // 1. Atualiza o progresso do objetivo
            IDENTIFICAR a parede que foi atingida (baseado na posição e direção)
            ADICIONAR a parede em paredes_encontradas

            // 2. Atualiza seu estado interno (memória)
            ESCOLHER uma nova direcao_atual que seja diferente da anterior
        FIM SE
        // Se o movimento foi bem-sucedido, o loop continua e ele tentará a mesma direção novamente

    FIM ENQUANTO

    EXIBIR "Perímetro do ambiente detectado."
FIM


================================================================
Etapa 2: Agente Reativo Baseado em Modelo
================================================================
Objetivo: Visitar o maior número de células do grid, evitando repetições.
Lógica: O agente usa uma memória (mapa) para priorizar a exploração de células novas.
INÍCIO
    DEFINIR mapa_visitados COMO um conjunto com a posição inicial
    DEFINIR caminho_pilha COMO uma pilha com a posição inicial // A memória do caminho
    DEFINIR passos_redundantes COMO 0

    // O loop continua enquanto houverem caminhos a serem explorados na pilha
    ENQUANTO a caminho_pilha NÃO está vazia FAÇA
        
        DEFINIR posicao_atual COMO o topo da caminho_pilha
        MOVER robô para posicao_atual // Simula o movimento
        
        // Encontra vizinhos que ainda não foram explorados
        DEFINIR vizinhos_nao_visitados COMO os vizinhos válidos de posicao_atual que NÃO estão em mapa_visitados

        SE a lista vizinhos_nao_visitados NÃO está vazia ENTÃO
            // Se há para onde ir, avança
            ESCOLHER um proximo_passo da lista vizinhos_nao_visitados
            
            ADICIONAR proximo_passo em mapa_visitados
            ADICIONAR proximo_passo na caminho_pilha // Memoriza o passo dado
        SENÃO
            // Se chegou a um beco sem saída, faz o backtracking inteligente
            REMOVER o topo da caminho_pilha
            INCREMENTAR passos_redundantes
        FIM SE
    FIM ENQUANTO
    
    EXIBIR "Exploração completa."
    EXIBIR métricas.
FIM


================================================================
Etapa 3: Agente Baseado em Objetivos
================================================================
Objetivo: Encontrar o caminho mais curto entre um ponto de início e um de destino.
Lógica: Utiliza o algoritmo de busca A* (A-Estrela).

FUNÇÃO A_Estrela(inicio, fim)
    // Dados uma célula de partida (xi , yi) e uma célula de destino (xf , yf)
    DEFINIR lista_aberta COMO uma fila de prioridade contendo o nó inicial
    DEFINIR veio_de COMO um mapa vazio para reconstruir o caminho

    DEFINIR g_score (custo do início ao nó) para todos os nós como infinito; DEFINIR g_score[inicio] COMO 0
    DEFINIR f_score (g_score + heurística) para todos os nós como infinito; DEFINIR f_score[inicio] COMO a distância heurística

    ENQUANTO lista_aberta NÃO está vazia FAÇA
        DEFINIR atual COMO o nó em lista_aberta com o menor f_score
        
        // Objetivo do Agente: encontrar e percorrer um caminho válido do início ao fim
        SE atual é igual a fim ENTÃO
            RETORNAR o caminho reconstruído a partir de veio_de
        FIM SE

        REMOVER atual de lista_aberta

        PARA CADA vizinho de atual QUE SEJA UMA CÉLULA VÁLIDA (sem obstáculo e dentro do grid) FAÇA
            // Custo de cada passo é 1
            DEFINIR tentativa_g_score COMO g_score[atual] + 1

            SE tentativa_g_score < g_score[vizinho] ENTÃO
                DEFINIR veio_de[vizinho] COMO atual
                DEFINIR g_score[vizinho] COMO tentativa_g_score
                DEFINIR f_score[vizinho] COMO g_score[vizinho] + distância heurística

                SE vizinho não está em lista_aberta ENTÃO
                    ADICIONAR vizinho em lista_aberta
                FIM SE
            FIM SE
        FIM PARA CADA
    FIM ENQUANTO

    RETORNAR falha (nenhum caminho encontrado)
FIM FUNÇÃO


================================================================
Etapa 4: Agente Baseado em Utilidade - Ambiente Completamente Observável
================================================================
Objetivo: Dado um mapa totalmente conhecido, encontrar o caminho de menor custo total entre o início and o fim.
Algoritmo: A lógica implementada é a do Algoritmo de Dijkstra, que é ideal para encontrar o caminho de menor custo em um grafo com pesos (custos) nas arestas (movimentos).

FUNÇÃO EncontrarCaminho_MenorCusto(inicio, fim, ambiente_completo)
    // A fila de prioridade armazena o CUSTO TOTAL para chegar a um nó, e o nó em si.
    DEFINIR lista_aberta COMO uma fila de prioridade contendo (0, inicio)
    
    // Armazena o caminho para reconstrução
    DEFINIR veio_de COMO um mapa vazio
    
    // Armazena o menor custo encontrado ATÉ AGORA para chegar a cada nó
    DEFINIR g_score (custo acumulado) para todos os nós como infinito
    DEFINIR g_score[inicio] COMO 0
    
    ENQUANTO lista_aberta NÃO está vazia FAÇA
        // Pega o nó da fila que tem o menor custo acumulado (g_score)
        DEFINIR custo_atual, atual COMO o item de menor custo em lista_aberta
        
        // Se já encontramos um caminho mais barato para este nó, ignoramos esta entrada
        SE custo_atual > g_score[atual] ENTÃO
            CONTINUAR para a próxima iteração
        FIM SE

        // Se chegamos ao destino, encontramos o caminho de menor custo
        SE atual é igual a fim ENTÃO
            RETORNAR o caminho reconstruído a partir de veio_de
        FIM SE
        
        PARA CADA vizinho de atual QUE SEJA UMA CÉLULA VÁLIDA FAÇA
            // Cada tipo de célula tem um "custo de movimento" associado
            DEFINIR custo_movimento COMO ambiente_completo.get_custo(vizinho)
            DEFINIR nova_g_score COMO g_score[atual] + custo_movimento
            
            // Se encontramos um caminho mais barato para o vizinho...
            SE nova_g_score < g_score[vizinho] ENTÃO
                // ...atualizamos seu custo e o caminho, e o adicionamos à fila para exploração.
                DEFINIR veio_de[vizinho] COMO atual
                DEFINIR g_score[vizinho] COMO nova_g_score
                ADICIONAR (g_score[vizinho], vizinho) em lista_aberta
            FIM SE
        FIM PARA CADA
    FIM ENQUANTO
    
    RETORNAR falha (nenhum caminho encontrado)
FIM FUNÇÃO



================================================================
Etapa 4: Agente Baseado em Utilidade - Ambiente Parcialmente Observável
================================================================
Objetivo: Encontrar o caminho de menor custo em um mapa desconhecido, onde o robô só pode "ver" uma pequena área ao seu redor.
Lógica: O agente opera em um ciclo contínuo de "Perceber-Planejar-Agir".

INÍCIO
    DEFINIR mapa_conhecido COMO um mapa vazio // Memória do robô sobre os custos
    DEFINIR caminho_percorrido COMO uma lista com a posição inicial
    
    // O ciclo de vida do agente
    ENQUANTO a posição atual do robô NÃO é igual ao fim FAÇA
    
        // 1. FASE DE PERCEPÇÃO
        // O robô "olha" ao redor e obtém os custos de terreno em sua vizinhança
        DEFINIR terrenos_visiveis COMO observar_arredores(posição atual)
        // Ele aprende, atualizando seu mapa mental com as novas informações
        ATUALIZAR mapa_conhecido com terrenos_visiveis
        
        // 2. FASE DE PLANEJAMENTO
        // O robô calcula o melhor caminho POSSÍVEL com a informação que tem ATÉ AGORA.
        // Ele usa o mesmo algoritmo de Dijkstra da Variação 1, mas com uma modificação crucial:
        //   - Para o custo de um 'vizinho', ele consulta seu 'mapa_conhecido'.
        //   - Se o 'vizinho' é uma célula que ele ainda não viu, ele assume um custo otimista (custo = 1).
        DEFINIR caminho_planejado COMO EncontrarCaminho_MenorCusto(posição atual, fim, mapa_conhecido)
        
        // Se não há como chegar ao destino com o conhecimento atual, a missão falha
        SE caminho_planejado é nulo ou tem menos de 2 passos ENTÃO
            EXIBIR "Falha: Caminho bloqueado ou impossível."
            PARAR o loop
        FIM SE
        
        // 3. FASE DE AÇÃO
        // O robô não segue o plano inteiro. Ele dá apenas o próximo passo.
        DEFINIR proximo_passo COMO o segundo item de caminho_planejado
        MOVER robô para proximo_passo
        ADICIONAR proximo_passo em caminho_percorrido
        
    FIM ENQUANTO
    
    EXIBIR "Missão concluída (ou falhou)."
FIM